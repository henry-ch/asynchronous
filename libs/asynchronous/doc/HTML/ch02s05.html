<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Diagnostics</title><link rel="stylesheet" href="boostbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Boost Asynchronous"><link rel="up" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Features"><link rel="prev" href="ch02s04.html" title="Interrupting"><link rel="next" href="ch02s06.html" title="Design Diagrams"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Diagnostics</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s04.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;2.&nbsp;Features</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch02s06.html">Next</a></td></tr></table><hr></div><div class="sect1" title="Diagnostics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e240"></a>Diagnostics</h2></div></div></div><p>Finding out how good your software is doing is not an easy task. You need to
                    add lots of logging to find out which function call takes too long and becomes a
                    bottleneck. Finding out the minimum required hardware to run your application is
                    even harder.</p><p>Asynchronous design helps here too. By logging the required time and the
                    frequency of tasks, it is easy to find out how many cores are needed.
                    Bottlenecks can be found by logging what the Active Component is doing and how
                    long. Finally, designing the asynchronous Active Component as state machines and
                    logging state changes will allow a better understanding of your system and make
                    visible potential for concurrency. Even for non-parallel algorithms, finding
                    out, using a state machine, the earliest point a task can be thrown to a
                    threadpool will give some easy concurrency. Throw enough tasks to the threadpool
                    and manage this with a state machine and you might use your cores with little
                    effort. In a second step, it is still possible to parallelize algorithms and
                    profit from smaller tasks divided among more cores. To find out if a task is
                    small enough to be parallelized, look at the diagnostics.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s04.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch02s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Interrupting&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Design Diagrams</td></tr></table></div></body></html>